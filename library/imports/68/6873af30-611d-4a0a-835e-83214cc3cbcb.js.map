{"version":3,"sources":["assets\\start-scene\\scripts\\AStar.ts"],"names":[],"mappings":"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","file":"","sourceRoot":"/","sourcesContent":["//  @\r\nexport class Node {\r\n    public walkable: boolean;\r\n    public costMultiplier: number;\r\n    public parent: Node;\r\n    public x: number;\r\n    public y: number;\r\n    public g: number;\r\n    public h: number;\r\n    public f: number;\r\n\r\n    constructor(x: number, y: number) {\r\n        this.walkable = false;\r\n        this.costMultiplier = 1;\r\n        this.x = x;\r\n        this.y = y;\r\n    }\r\n}\r\n\r\n// @\r\nclass Grid {\r\n    private _numCols: number;\r\n    private _numRows: number;\r\n    private _nodes: Node[][];\r\n    private _startNode: Node | null;\r\n    private _endNode: Node | null;\r\n\r\n    // @\r\n    constructor(numCols: number | { numCols: number; numRows: number; getNodes: () => Node[][] }, numRows?: number) {\r\n        if (numRows !== undefined) {\r\n            this._numCols = numCols as number;\r\n            this._numRows = numRows;\r\n            this._nodes = [];\r\n            for (let a = 0; a < this._numCols; a++) {\r\n                this._nodes[a] = [];\r\n                for (let i = 0; i < this._numRows; i++) {\r\n                    this._nodes[a][i] = new Node(a, i);\r\n                }\r\n            }\r\n        } else {\r\n            this._numCols = (numCols as { numCols: number; numRows: number }).numCols;\r\n            this._numRows = (numCols as { numCols: number; numRows: number }).numRows;\r\n            this._nodes = (numCols as { getNodes: () => Node[][] }).getNodes();\r\n        }\r\n        this._startNode = null;\r\n        this._endNode = null;\r\n    }\r\n\r\n    // @\r\n    private validNode(x: number, y: number): boolean {\r\n        return !(x < 0 || x >= this.numCols || y < 0 || y >= this.numRows);\r\n    }\r\n\r\n    // @\r\n    private getNodes(): Node[][] {\r\n        return this._nodes;\r\n    }\r\n\r\n    // @\r\n    public getNode(x: number, y: number): Node {\r\n        return this._nodes[x][y];\r\n    }\r\n\r\n    // @\r\n    public setEndNode(x: number, y: number): void {\r\n        this._endNode = this._nodes[x][y];\r\n    }\r\n\r\n    // @\r\n    public setStartNode(x: number, y: number): void {\r\n        this._startNode = this._nodes[x][y];\r\n    }\r\n\r\n    // @\r\n    public setWalkable(x: number, y: number, walkable: boolean): void {\r\n        if (0 <= x && x < this._nodes.length) {\r\n            const row = this._nodes[x];\r\n            if (0 <= y && y < row.length) {\r\n                this._nodes[x][y].walkable = walkable;\r\n                return;\r\n            }\r\n        }\r\n        cc.error(\"The array index passed in is out of bounds\"); // 传入的数组索引越界\r\n    }\r\n\r\n    // @\r\n    public getWalkable(x: number, y: number): boolean {\r\n        if (0 <= x && x < this._nodes.length) {\r\n            const row = this._nodes[x];\r\n            if (0 <= y && y < row.length) {\r\n                return row[y].walkable;\r\n            }\r\n        }\r\n        cc.error(\"The array index passed in is out of bounds\"); // 传入的数组索引越界\r\n        return false;\r\n    }\r\n\r\n    // @\r\n    public get endNode(): Node | null {\r\n        return this._endNode;\r\n    }\r\n\r\n    // @\r\n    public get numCols(): number {\r\n        return this._numCols;\r\n    }\r\n\r\n    // @\r\n    public get numRows(): number {\r\n        return this._numRows;\r\n    }\r\n\r\n    // @\r\n    public get startNode(): Node | null {\r\n        return this._startNode;\r\n    }\r\n\r\n    // @\r\n    public clearStartAndEndNode(): void {\r\n        this._startNode = null;\r\n        this._endNode = null;\r\n    }\r\n} // end: Grid\r\n\r\n// @\r\nclass AStar {\r\n    private _grid: Grid;\r\n    private _open: Node[];\r\n    private _closed: Node[];\r\n    private _startNode: Node | null;\r\n    private _endNode: Node | null;\r\n    private _straightCost: number;\r\n    private _diagCost: number;\r\n    private _allowDiag: boolean;\r\n    private _heuristic: (node: Node) => number;\r\n    private _path: Node[];\r\n\r\n    // @\r\n    constructor() {\r\n        this._open = [];\r\n        this._closed = [];\r\n        this._straightCost = 1;\r\n        this._diagCost = Math.SQRT2;\r\n        this._allowDiag = false;\r\n        this._heuristic = this.diagonal;\r\n        this._path = [];\r\n    }\r\n\r\n    // @\r\n    private allowDiag(allow: boolean): void {\r\n        this._allowDiag = allow;\r\n    }\r\n\r\n    // @\r\n    public findPath(grid: Grid): boolean {\r\n        this._grid = grid;\r\n        this._open = [];\r\n        this._closed = [];\r\n        this._startNode = this._grid.startNode;\r\n        this._endNode = this._grid.endNode;\r\n        if (this._startNode) {\r\n            this._startNode.g = 0;\r\n            this._startNode.h = this._heuristic(this._startNode);\r\n            this._startNode.f = this._startNode.g + this._startNode.h;\r\n        }\r\n        if (this._startNode && this._endNode) return this.search();\r\n        return false;\r\n    }\r\n\r\n    // @\r\n    private search(): boolean {\r\n        let currentNode: Node = this._startNode;\r\n        while (currentNode !== this._endNode) {\r\n            for (\r\n                let l = Math.max(0, currentNode.x - 1),\r\n                r = Math.min(this._grid.numCols - 1, currentNode.x + 1),\r\n                s = Math.max(0, currentNode.y - 1),\r\n                c = Math.min(this._grid.numRows - 1, currentNode.y + 1);\r\n                l <= r;\r\n                l++\r\n            ) {\r\n                for (let _ = s; _ <= c; _++) {\r\n                    if (!this._allowDiag && l !== currentNode.x && _ !== currentNode.y) continue;\r\n                    const neighborNode = this._grid.getNode(l, _);\r\n                    if (neighborNode !== currentNode && neighborNode.walkable && this._grid.getNode(currentNode.x, neighborNode.y).walkable && this._grid.getNode(neighborNode.x, currentNode.y).walkable) {\r\n                        let cost = this._straightCost;\r\n                        if (currentNode.x !== neighborNode.x && currentNode.y !== neighborNode.y) {\r\n                            cost = this._diagCost;\r\n                        }\r\n                        const gCost = currentNode.g + cost * neighborNode.costMultiplier;\r\n                        const hCost = this._heuristic(neighborNode);\r\n                        const fCost = gCost + hCost;\r\n\r\n                        if (this.isOpen(neighborNode) || this.isClosed(neighborNode)) {\r\n                            if (neighborNode.f > fCost) {\r\n                                neighborNode.f = fCost;\r\n                                neighborNode.g = gCost;\r\n                                neighborNode.h = hCost;\r\n                                neighborNode.parent = currentNode;\r\n                            }\r\n                        } else {\r\n                            neighborNode.f = fCost;\r\n                            neighborNode.g = gCost;\r\n                            neighborNode.h = hCost;\r\n                            neighborNode.parent = currentNode;\r\n                            this._open.push(neighborNode);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n\r\n            this._closed.push(currentNode);\r\n            if (this._open.length === 0) return false;\r\n\r\n            this._open.sort((a, b) => a.f - b.f);\r\n            currentNode = this._open.shift()!;\r\n        }\r\n        this.buildPath();\r\n        return true;\r\n    } // end: search\r\n\r\n    // @\r\n    private buildPath(): void {\r\n        this._path = [];\r\n        let node: Node | null = this._endNode;\r\n        while (node !== this._startNode) {\r\n            this._path.unshift(node);\r\n            node = node.parent;\r\n        }\r\n        this._path.unshift(this._startNode);\r\n    }\r\n\r\n    // @\r\n    public get path(): Node[] {\r\n        return this._path;\r\n    }\r\n\r\n    // @\r\n    private isOpen(node: Node): boolean {\r\n        return this._open.includes(node);\r\n    }\r\n\r\n    // @\r\n    private isClosed(node: Node): boolean {\r\n        return this._closed.includes(node);\r\n    }\r\n\r\n    // @\r\n    private manhattan(node: Node): number {\r\n        return Math.abs(node.x - this._endNode!.x) * this._straightCost + Math.abs(node.y - this._endNode!.y) * this._straightCost;\r\n        // phép toán gốc là dòng bên dưới nhưng AI tạo ra dòng trên có vẻ đã xử lý đúng hơn.\r\n        // return Math.abs(node.x - this._endNode!.x) * this._straightCost + Math.abs(node.y + this._endNode!.y) * this._straightCost;\r\n    }\r\n\r\n    // @\r\n    private euclidian(node: Node): number {\r\n        const dx = node.x - this._endNode!.x;\r\n        const dy = node.y - this._endNode!.y;\r\n        return Math.sqrt(dx * dx + dy * dy) * this._straightCost;\r\n    }\r\n\r\n    // @\r\n    private diagonal(node: Node): number {\r\n        const dx = Math.abs(node.x - this._endNode!.x);\r\n        const dy = Math.abs(node.y - this._endNode!.y);\r\n        const min = Math.min(dx, dy);\r\n        return this._diagCost * min + this._straightCost * (dx + dy - 2 * min);\r\n    }\r\n\r\n    // @\r\n    private get visited(): Node[] {\r\n        return this._closed.concat(this._open);\r\n    }\r\n}\r\n\r\nexport { Grid, AStar };\r\n"]}